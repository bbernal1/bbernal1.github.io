---
title: "Leetcode 226. Invert Binary Tree"
excerpt_separator: <!--more-->
categories:
  - Leetcode
tags:
  - Coding
---
For this problem I am given the root of a binary tree and I must return a fully inverted tree.
<!--more-->
URL: [https://leetcode.com/problems/invert-binary-tree/](https://leetcode.com/problems/invert-binary-tree/)

{% highlight java %}
My solution:

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return root;
        }
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
}
{% endhighlight %}
Explanation:  
Line 32 handles the case wher the root is null (the tree has 0 nodes) and it is also the base case of the recursive algorithm.  
Lines 35-37 swap the left and right pointer of the root.  
Line 38 and 39 run the procedure recursively on the left and right child nodes. The return value is not needed for these calls.  
Finally, the caller function retrieves the root from line 40
